package uk.ac.cam.ch.wwmm.opsin;

import java.util.ArrayList;
import java.util.List;
import java.util.Set;
import java.util.regex.Pattern;

import nu.xom.Attribute;
import nu.xom.Element;
import nu.xom.Elements;
import static  uk.ac.cam.ch.wwmm.opsin.StructureBuildingMethods.*;

/**Constructs a single OPSIN fragment which describes the molecule from the postprocessor results.
 *
 * @author ptc24/dl387
 *
 */
class StructureBuilder {

	private static Pattern matchDigits = Pattern.compile("\\d+");

	/**	Builds a molecule as a Fragment based on preStructurebuilder output.
	 * @param state
	 * @param molecule The preStructurebuilderr output.
	 * @return A single Fragment - the built molecule.
	 * @throws StructureBuildingException If the molecule won't build - there may be many reasons.
	 */
	Fragment buildFragment(BuildState state, Element molecule) throws StructureBuildingException {
		String wordRule = state.wordRule;
		Elements words = molecule.getChildElements();
		if (words.size()==0){
			throw new StructureBuildingException("Molecule contains no words!?");
		}

		if(wordRule.equals("simple")) {
			Element word = molecule.getFirstChildElement("word");
			resolveWordOrBracket(state, word);
		}
		else if (wordRule.equals("acid")){
			buildAcid(state,words);//ethanoic acid
		}
		else if(wordRule.equals("ester") || wordRule.equals("multiEster")) {
			buildEster(state, words);//e.g. ethyl ethanoate, dimethyl terephthalate,  methyl propanamide
		}
		else if (wordRule.equals("divalentLiteralFunctionalGroup")){
			buildDiValentLiteralFunctionalGroup(state, words);// diethyl ether or methyl propyl ketone
		}
		else if (wordRule.equals("monovalentFunctionalGroup")){
			buildMonovalentFunctionalGroup(state, words);// ethyl chloride or isophthaloyl dichloride
		}
		else if (wordRule.equals("monovalentLiteralFunctionalGroup")){
			buildMonovalentLiteralFunctionalGroup(state, words);//e.g. diethyl ether, ethyl alcohol
		}
		else if(wordRule.equals("functionalClassEster")) {
			buildFunctionalClassEster(state, words);//e.g. ethanoic acid ethyl ester, tetrathioterephthalic acid dimethyl ester
		}
		else if (wordRule.equals("amide")){
			buildAmide(state, words);//e.g. ethanoic acid ethyl amide, terephthalic acid dimethyl amide, ethanoic acid amide
		}
		else if (wordRule.equals("glycol")){
			buildGlycol(state, words);//e.g. ethylene glycol
		}
		else if(wordRule.equals("oxime")) {
			buildOxime(state, words);//e.g. Imidazole-2-carboxamide O-ethyloxime, pentan-3-one oxime
		}
		else if(wordRule.equals("binaryOrOther")) {
			for (int i = 0; i < words.size(); i++) {
				resolveWordOrBracket(state, words.get(i));
			}
		}
		else if(wordRule.equals("polymer")) {
			buildPolymer(state, words);
		}
		else{
			throw new StructureBuildingException("Unknown Word Rule");
		}

		state.fragManager.convertSpareValenciesToDoubleBonds();
		state.fragManager.checkValencies();
		makeHydrogensExplicit(state);

		Fragment uniFrag = state.fragManager.getUnifiedFragment();
		List<Element> stereoChemistryEls = XOMTools.getDescendantElementsWithTagName(molecule, "stereoChemistry");
		if (stereoChemistryEls.size() >0){
			StereochemistryHandler.processStereochemicalElements(state, molecule, uniFrag, stereoChemistryEls);
		}

		//adds Xe group at all atoms which have unused outIDs
		//note that SMILES generated by CDK is not always correct
//		BuildResults moleculeBuildResults =  new BuildResults(state, molecule);
//		for (int i = 0; i < moleculeBuildResults.getOutIDCount(); i++) {
//			Atom outAtom =moleculeBuildResults.getOutAtomTakingIntoAccountWhetherSetExplicitly(i);
//			Fragment rGroup =state.fragManager.buildSMILES("[Xe]");
//			state.fragManager.attachFragments(outAtom, rGroup.getAtomByIDOrThrow(rGroup.getIdOfFirstAtom()), moleculeBuildResults.getOutID(i).valency);
//		}

		if (uniFrag.getOutIDs().size()>0 || uniFrag.getInIDs().size()>0){
			throw new StructureBuildingException("Radicals are currently set to not convert to structures");
		}
		return uniFrag;
	}

	private void buildAcid(BuildState state, Elements words) throws StructureBuildingException {
		resolveWordOrBracket(state, words.get(0));
		if (words.size()<2 || !words.get(1).getAttributeValue("type").equals("literal")){
			throw new StructureBuildingException("literal word acid missing");
		}
		resolveTrailingFullWords(state, words, 2);
	}

	private void buildEster(BuildState state, Elements words) throws StructureBuildingException {
		int wordIndice = resolvePreceedingFullWordsAndReturnNonFullIndice(state, words);
		Element currentWord=words.get(wordIndice);
		BuildResults substituentsBr = new BuildResults();
		while (currentWord.getAttributeValue("type").equals("substituent")){
			resolveWordOrBracket(state, currentWord);
			BuildResults substituentBr = new BuildResults(state, currentWord);
			if (substituentBr.getOutIDCount() ==1){//TODO add support for locanted terepthaloyl
				String locantForSubstituent = getLocantForSubstituent(currentWord);
				if (locantForSubstituent!=null){
					substituentBr.getFirstOutID().locant=locantForSubstituent;//indexes which functional atom to connect to when there is a choice. Also can disambiguate which atom is a S in things like thioates
				}
			}
			else if (substituentBr.getOutIDCount() ==0){
				throw new StructureBuildingException("Substituent was expected to have at least one outID");
			}
			substituentsBr.mergeBuildResults(substituentBr);
			currentWord=words.get(++wordIndice);
		}

		if (wordIndice == words.size() || !words.get(wordIndice).getAttributeValue("type").equals("full")){
			throw new StructureBuildingException("Full word not found where full word expected: missing ate group in ester");
		}

		BuildResults ateGroups = new BuildResults();
		for (; wordIndice < words.size(); wordIndice++) {
			Element word =words.get(wordIndice);
			if (word.getAttributeValue("type").equals("full")){
				resolveWordOrBracket(state, word);
				BuildResults ateBR = new BuildResults(state, word);
				ateGroups.mergeBuildResults(ateBR);
			}
			else{
				throw new StructureBuildingException("Non full word found where only full words were expected");
			}
		}
		int esterIdCount = ateGroups.getFunctionalIDCount();
		int outIDCount =substituentsBr.getOutIDCount();
		if (outIDCount > esterIdCount){
			throw new StructureBuildingException("There are more radicals in the substituents(" + outIDCount +") than there are places to form esters("+esterIdCount+")");
		}
		for(int i=0; i< outIDCount; i++) {
			Atom ateAtom;
			if (substituentsBr.getFirstOutID().locant!=null){
				ateAtom =determineFunctionalAtomToUse(substituentsBr.getFirstOutID().locant, ateGroups);
			}
			else{
				ateAtom =ateGroups.getFunctionalAtom(0);
				ateGroups.removeFunctionalID(0);
			}
			state.fragManager.createBond(ateAtom,substituentsBr.getOutAtomTakingIntoAccountWhetherSetExplicitly(0), 1);
			substituentsBr.removeOutID(0);
			ateAtom.setCharge(0);
		}
	}



	private void buildDiValentLiteralFunctionalGroup(BuildState state, Elements words) throws StructureBuildingException {
		int wordIndice = resolvePreceedingFullWordsAndReturnNonFullIndice(state, words);
		if (!words.get(wordIndice).getAttributeValue("type").equals("substituent")) {
			throw new StructureBuildingException("word: " +wordIndice +" was expected to be a substituent");
		}
		if (words.get(wordIndice +1).getAttributeValue("type").equals("literal")) {//e.g. methyl sulfoxide rather than dimethyl sulfoxide
			Element clone = state.fragManager.cloneElement(state, words.get(0));
			XOMTools.insertAfter(words.get(0), clone);
			words = ((Element)words.get(0).getParent()).getChildElements();
		}
		resolveWordOrBracket(state, words.get(wordIndice));
		BuildResults substituent1 =new BuildResults(state, words.get(wordIndice));
		if (substituent1.getOutIDCount()!=1){
			throw new StructureBuildingException("Expected one out outID. Found " + substituent1.getOutIDCount() );
		}
		if (substituent1.getOutID(0).valency !=1){
			throw new StructureBuildingException("OutID has unexpected valency. Expected 1. Actual: " + substituent1.getOutID(0).valency);
		}
		wordIndice++;
		resolveWordOrBracket(state, words.get(wordIndice));
		BuildResults substituent2 =new BuildResults(state, words.get(wordIndice));
		if (substituent2.getOutIDCount()!=1){
			throw new StructureBuildingException("Expected one out outID. Found " + substituent2.getOutIDCount() );
		}
		if (substituent2.getOutID(0).valency !=1){
			throw new StructureBuildingException("OutID has unexpected valency. Expected 1. Actual: " + substituent2.getOutID(0).valency);
		}
		wordIndice++;
		if (words.get(wordIndice) ==null || !words.get(wordIndice).getAttributeValue("type").equals("literal")) {
			throw new StructureBuildingException("word: " +wordIndice +" was expected to be a literal");
		}
		String smilesOfGroup = null;
		String functionalGroupName =words.get(wordIndice).getValue();
		if (functionalGroupName.equalsIgnoreCase("ether")){
			smilesOfGroup="O";
		}
		else if (functionalGroupName.equalsIgnoreCase("ketone")){
			smilesOfGroup="C=O";
		}
		else if (functionalGroupName.equalsIgnoreCase("peroxide")){
			smilesOfGroup="OO-";
		}
		else if (functionalGroupName.equalsIgnoreCase("selenide")){
			smilesOfGroup="[Se]";
		}
		else if (functionalGroupName.equalsIgnoreCase("selenone")){
			smilesOfGroup="[Se](=O)=O";
		}
		else if (functionalGroupName.equalsIgnoreCase("selenoxide")){
			smilesOfGroup="[Se]=O";
		}
		else if (functionalGroupName.equalsIgnoreCase("selone")){
			smilesOfGroup="C=[Se]";
		}
		else if (functionalGroupName.equalsIgnoreCase("selenoketone")){
			smilesOfGroup="[Se]=O";
		}
		else if (functionalGroupName.equalsIgnoreCase("sulfide")){
			smilesOfGroup="S";
		}
		else if (functionalGroupName.equalsIgnoreCase("sulfone")){
			smilesOfGroup="S(=O)=O";
		}
		else if (functionalGroupName.equalsIgnoreCase("sulfoxide")){
			smilesOfGroup="S=O";
		}
		else if (functionalGroupName.equalsIgnoreCase("telluride")){
			smilesOfGroup="[Te]";
		}
		else if (functionalGroupName.equalsIgnoreCase("telluroketone")){
			smilesOfGroup="[Te]=O";
		}
		else if (functionalGroupName.equalsIgnoreCase("tellurone")){
			smilesOfGroup="[Te](=O)=O";
		}
		else if (functionalGroupName.equalsIgnoreCase("telluroxide")){
			smilesOfGroup="[Te]=O";
		}
		else if (functionalGroupName.equalsIgnoreCase("thioketone")){
			smilesOfGroup="S=O";
		}
		else{
			throw new StructureBuildingException("Unknown functionalGroup: " + functionalGroupName);
		}
		Fragment diValentGroup =state.fragManager.buildSMILES(smilesOfGroup, "simpleGroup", "functionalGroup", "none");

		Atom outAtom =substituent1.getOutAtomTakingIntoAccountWhetherSetExplicitly(0);
		substituent1.removeOutID(0);
		if (diValentGroup.getOutIDs().size()==1){//c.f. peroxide where it is a linker
			state.fragManager.createBond(outAtom, diValentGroup.getAtomByIDOrThrow(diValentGroup.getOutID(0).id), 1);
			diValentGroup.removeOutID(0);
		}
		else{
			state.fragManager.createBond(outAtom, diValentGroup.getAtomByIDOrThrow(diValentGroup.getIdOfFirstAtom()), 1);
		}
		outAtom = substituent2.getOutAtomTakingIntoAccountWhetherSetExplicitly(0);
		substituent2.removeOutID(0);
		state.fragManager.createBond(outAtom, diValentGroup.getAtomByIDOrThrow(diValentGroup.getIdOfFirstAtom()), 1);
		resolveTrailingFullWords(state, words, wordIndice + 1);
	}

	private void buildMonovalentFunctionalGroup(BuildState state, Elements words) throws StructureBuildingException {
		int wordIndice = resolvePreceedingFullWordsAndReturnNonFullIndice(state, words);
		resolveWordOrBracket(state, words.get(wordIndice));
		List<Element> groups = XOMTools.getDescendantElementsWithTagName(words.get(0), "group");
		for (Element group : groups) {//replaces outIDs with valency greater than 1 with multiple outIDs; e.g. ylidene -->diyl
			Fragment frag = state.xmlFragmentMap.get(group);
			for (int i = frag.getOutIDs().size()-1; i>=0; i--) {
				OutID outID =frag.getOutID(i);
				if (outID.valency>1){
					for (int j = 2; j <= outID.valency; j++) {
						frag.addOutID(outID.id, 1, outID.setExplicitly);
					}
					outID.valency=1;
				}
			}
		}
		BuildResults substituentBR = new BuildResults(state, words.get(0));

		int numberOfOutIDs =substituentBR.getOutIDCount();
		if (numberOfOutIDs > words.size()-1){//something like isophthaloyl chloride (more precisely written isophthaloyl dichloride)
			if (words.size()-wordIndice != 2){
				throw new StructureBuildingException("Incorrect number of functional class groups found to balance outIDs");
			}
			int diff =numberOfOutIDs - (words.size()-wordIndice -1);
			Element elementToBeCloned =words.get(words.size()-1);
			for (int i = 0; i < diff; i++) {
				Element clone =state.fragManager.cloneElement(state, elementToBeCloned);
				XOMTools.insertAfter(elementToBeCloned, clone);
				elementToBeCloned=clone;
			}
			words = ((Element)words.get(0).getParent()).getChildElements();//update words
		}
		for (int i = 0; i < numberOfOutIDs; i++) {
			wordIndice++;
			resolveWordOrBracket(state, words.get(wordIndice));
			Element ideGroup = StructureBuildingMethods.findRightMostGroupInBracket(words.get(wordIndice));
			Fragment ideFrag = state.xmlFragmentMap.get(ideGroup);
			Atom ideAtom = ideFrag.getAtomByIDOrThrow(ideFrag.getDefaultInID());
			Atom subAtom=substituentBR.getOutAtomTakingIntoAccountWhetherSetExplicitly(0);
			state.fragManager.createBond(ideAtom, subAtom, 1);
			substituentBR.removeOutID(0);
			ideAtom.setCharge(ideAtom.getCharge()+1);
		}
		resolveTrailingFullWords(state, words, ++wordIndice);//e.g. ethyl chloride hydrochloride
	}

	private void buildMonovalentLiteralFunctionalGroup(BuildState state,Elements words) throws StructureBuildingException {
		int wordIndice = resolvePreceedingFullWordsAndReturnNonFullIndice(state, words);
		resolveWordOrBracket(state, words.get(wordIndice));//the substituent
		BuildResults substituentBr = new BuildResults(state, words.get(wordIndice));
		wordIndice++;
		String smilesOfGroup = null;
		String functionalGroupName =words.get(wordIndice++).getValue();
		if (functionalGroupName.equalsIgnoreCase("alcohol")){
			smilesOfGroup="O";
		}
		else if (functionalGroupName.equalsIgnoreCase("selenol")){
			smilesOfGroup="[Se]";
		}
		else if (functionalGroupName.equalsIgnoreCase("thiol")){
			smilesOfGroup="S";
		}
		else{
			throw new StructureBuildingException("Unknown functionalGroup: " + functionalGroupName);
		}
		for (int i = 0; i < substituentBr.getOutIDCount(); i++) {
			Atom outAtom = substituentBr.getOutAtomTakingIntoAccountWhetherSetExplicitly(i);
			Fragment rGroup =state.fragManager.buildSMILES(smilesOfGroup, "monovalentgroup", "none");
			if (substituentBr.getOutID(i).valency !=1){
				throw new StructureBuildingException("OutID has unexpected valency. Expected 1. Actual: " + substituentBr.getOutID(i).valency);
			}
			state.fragManager.createBond(outAtom, rGroup.getAtomByIDOrThrow(rGroup.getIdOfFirstAtom()), 1);
			substituentBr.removeOutID(i);
		}
		resolveTrailingFullWords(state, words, wordIndice);
	}

	private void buildFunctionalClassEster(BuildState state, Elements words) throws StructureBuildingException {
		if (!words.get(0).getAttributeValue("type").equals("full")){
			throw new StructureBuildingException("Don't alter wordRules.xml without checking the consequences!");
		}
		resolveWordOrBracket(state, words.get(0));//the group
		BuildResults acidBr = new BuildResults(state, words.get(0));
		if (!words.get(1).getAttributeValue("type").equals("literal")){//acid
			throw new StructureBuildingException("Don't alter wordRules.xml without checking the consequences!");
		}
		if (acidBr.getFunctionalIDCount()==0){
			throw new StructureBuildingException("No functionalIds detected!");
		}

		int i=2;
		Element currentWord = words.get(i);
		while (currentWord.getAttributeValue("type").equals("substituent")){
			if (acidBr.getFunctionalIDCount()==0){
				throw new StructureBuildingException("Insufficient functionalIDs on acid");
			}
			resolveWordOrBracket(state, currentWord);
			BuildResults substituentBr = new BuildResults(state, currentWord);
			if (substituentBr.getOutIDCount() ==1){
				String locantForSubstituent = getLocantForSubstituent(currentWord);
				Atom functionalAtom;
				if (locantForSubstituent!=null){
					functionalAtom =determineFunctionalAtomToUse(locantForSubstituent, acidBr);
				}
				else{
					functionalAtom =acidBr.getFunctionalAtom(0);
					acidBr.removeFunctionalID(0);
				}
				if (substituentBr.getOutID(0).valency!=1){
					throw new StructureBuildingException("Substituent was expected to have only have an outgoing valency of 1");
				}
				state.fragManager.createBond(functionalAtom,substituentBr.getOutAtomTakingIntoAccountWhetherSetExplicitly(0), 1);
				substituentBr.removeOutID(0);
			}
			else {
				throw new StructureBuildingException("Substituent was expected to have one outID");
			}
			currentWord=words.get(++i);
		}
		if (!words.get(i++).getAttributeValue("type").equals("literal")){//ester
			throw new StructureBuildingException("Number of words different to expectations; did not find ester");
		}
		resolveTrailingFullWords(state, words, i);
	}

	private void buildAmide(BuildState state, Elements words) throws StructureBuildingException {
		if (!words.get(0).getAttributeValue("type").equals("full")){
			throw new StructureBuildingException("Don't alter wordRules.xml without checking the consequences!");
		}
		resolveWordOrBracket(state, words.get(0));//the group
		BuildResults acidBr = new BuildResults(state, words.get(0));
		if (acidBr.getFunctionalIDCount()==0){
			throw new StructureBuildingException("No functionalIds detected!");
		}
		if (!words.get(1).getAttributeValue("type").equals("literal")){//acid
			throw new StructureBuildingException("Don't alter wordRules.xml without checking the consequences!");
		}
		int substituentCount = XOMTools.getChildElementsWithTagNameAndAttribute((Element) words.get(0).getParent(), "word", "type", "substituent").size();
		if (acidBr.getFunctionalIDCount() < substituentCount){
			throw new StructureBuildingException("More substituents than acid functionalIDs detcted during amide construction!");
		}
		if (substituentCount==0){//e.g. ethanoic acid amide
			for (int i =0; i < acidBr.getFunctionalIDCount(); i++) {
				Atom functionalAtom = acidBr.getFunctionalAtom(i);
				if (!functionalAtom.getElement().equals("O")){
					throw new StructureBuildingException("Expected oxygen functional atom found:" + functionalAtom.getElement());
				}
				functionalAtom.setElement("N");
				functionalAtom.replaceLocant("N" +StringTools.multiplyString("'", i));
			}
		}
		int wordIndice;
		for (wordIndice = 2 ; wordIndice < 2 + substituentCount; wordIndice++) {
			if (!words.get(wordIndice).getAttributeValue("type").equals("substituent")){
				throw new StructureBuildingException("Word: " + wordIndice + " was expected to be a substituent");
			}
			//a fragment is constructed which is just the Nitrogen atom of the amide
			Element dummyRoot = new Element("root");
			Element dummGroup = new Element("group");
			dummyRoot.appendChild(dummGroup);
			Fragment dummyFrag = state.fragManager.buildSMILES("N", "suffix", "N");
			state.xmlFragmentMap.put(dummGroup, dummyFrag);
			words.get(wordIndice).appendChild(dummyRoot);
			resolveWordOrBracket(state, words.get(wordIndice));
			BuildResults substituentBr = new BuildResults(state, words.get(wordIndice));
			if (substituentBr.getOutIDCount()!=0){
				throw new StructureBuildingException("Substituent should have not OutIDs after forming amide");
			}

			Atom functionalAtom = acidBr.getFunctionalAtom(0);
			if (!functionalAtom.getElement().equals("O")){
				throw new StructureBuildingException("Expected oxygen functional atom found:" + functionalAtom.getElement());
			}
			acidBr.removeFunctionalID(0);
			state.fragManager.replaceTerminalAtomWithFragment(functionalAtom, dummyFrag.getFirstAtom());//the first atom will be the amide N
		}
		if (!words.get(wordIndice++).getAttributeValue("type").equals("literal")){//amide
			throw new StructureBuildingException("Number of words different to expectations; did not find amide");
		}
		resolveTrailingFullWords(state, words, wordIndice);
	}

	private void buildGlycol(BuildState state, Elements words) throws StructureBuildingException {
		int wordIndice  = resolvePreceedingFullWordsAndReturnNonFullIndice(state, words);
		resolveWordOrBracket(state, words.get(wordIndice));//the group
		BuildResults theDiRadical = new BuildResults(state, words.get(wordIndice));
		if (theDiRadical.getOutIDCount()!=2){
			throw new StructureBuildingException("Glycol class names (e.g. ethylene glycol) expect two outIDs. Found: " + theDiRadical.getOutIDCount() );
		}
		if (wordIndice +1 >= words.size() || words.get(wordIndice+1).getAttributeValue("type").equals("glycol")){
			throw new StructureBuildingException("Glycol literal word expected");
		}
		for (int i = 0; i < theDiRadical.getOutIDCount(); i++) {
			Atom outAtom =theDiRadical.getOutAtomTakingIntoAccountWhetherSetExplicitly(i);
			Fragment glycol =state.fragManager.buildSMILES("O", "glycol", "none");
			if (theDiRadical.getOutID(i).valency !=1){
				throw new StructureBuildingException("OutID has unexpected valency. Expected 1. Actual: " + theDiRadical.getOutID(i).valency);
			}
			theDiRadical.removeOutID(0);
			state.fragManager.createBond(outAtom, glycol.getAtomByIDOrThrow(glycol.getIdOfFirstAtom()), 1);
		}
		resolveTrailingFullWords(state, words, wordIndice + 2);
	}

	private void buildOxime(BuildState state, Elements words) throws StructureBuildingException {
		int wordIndice  = resolvePreceedingFullWordsAndReturnNonFullIndice(state, words);
		BuildResults moleculeToModify = new BuildResults(state, words.get(wordIndice-1));//the group which the oxime will modify
		BuildResults substituentBR;
		if (words.get(wordIndice).getAttributeValue("type").equals("literal") && words.get(wordIndice).getValue().equals("oxime")){
			substituentBR = null;
		}
		else if (words.get(wordIndice).getAttributeValue("type").equals("substituent")){
			resolveWordOrBracket(state, words.get(wordIndice));
			substituentBR = new BuildResults(state, words.get(wordIndice));
			wordIndice++;
			if (!words.get(wordIndice).getAttributeValue("type").equals("literal") || !words.get(wordIndice).getValue().equals("oxime")){
				throw new StructureBuildingException("Expected literal(oxime)");
			}
		}
		else{
			throw new StructureBuildingException("Expected either substituent or literal(oxime)");//TODO support dioxime, trioxime etc.
		}

		int numberOfOximes =1;
		List<Atom> matches = new ArrayList<Atom>();
		for (Fragment frag : moleculeToModify.getFragments()){//find all carbonyl oxygen
			List<Atom> atomList = frag.getAtomList();
			for (Atom atom : atomList) {
				if (atom.getElement().equals("O") && atom.getCharge()==0){
					List<Atom> neighbours =atom.getAtomNeighbours();
					if (neighbours.size()==1){
						if (neighbours.get(0).getElement().equals("C")){
							Bond b = frag.findBond(atom, neighbours.get(0));
							if (b !=null && b.getOrder()==2){
								matches.add(atom);
							}
						}
					}
				}
			}
		}
		if (matches.size() < numberOfOximes){
			throw new StructureBuildingException("Insufficient carbonyl groups found!");
		}

		for (int i = 0; i < numberOfOximes; i++) {
			Atom atomToBeReplaced =matches.get(i);//the oxygen of the carbonyl
			Fragment parentFrag =atomToBeReplaced.getFrag();
			atomToBeReplaced.setElement("N");
			List<Atom> parentFragAtomList =parentFrag.getAtomList();
			for (Atom atom :parentFragAtomList) {
				if (atom.hasLocant("O")){
					atom.removeLocant("O");
				}
			}
			Atom addedHydroxy = state.fragManager.createAtom("O", parentFrag);
			addedHydroxy.addLocant("O");
			parentFrag.addAtom(addedHydroxy);
			state.fragManager.createBond(atomToBeReplaced, addedHydroxy, 1);
			if (i== 0 && substituentBR !=null){
				if (substituentBR.getOutIDCount() !=1){
					throw new StructureBuildingException("Expected outID on substituent before oxime");
				}
				String locant = getLocantForSubstituent(words.get(wordIndice -1));
				if (locant !=null && !locant.startsWith("O")){
					throw new StructureBuildingException("The only locant expected for a substituent connecting to an oxime is an O. Found: " + locant);
				}
				state.fragManager.createBond(addedHydroxy, substituentBR.getOutAtomTakingIntoAccountWhetherSetExplicitly(0), substituentBR.getOutID(0).valency);
				substituentBR.removeOutID(0);
			}
		}
		resolveTrailingFullWords(state, words, ++wordIndice);
	}

	private void buildPolymer(BuildState state, Elements words) throws StructureBuildingException {
		if (words.size()>1){
			throw new StructureBuildingException("Currently unsupported polymer name type");
		}
		Element polymer = words.get(0);
		resolveWordOrBracket(state, polymer);
		BuildResults polymerBr = new BuildResults(state, polymer);
		if (polymerBr.getOutIDCount() ==2 && polymerBr.getInIDCount()==0){
			Atom inAtom =polymerBr.getOutAtomTakingIntoAccountWhetherSetExplicitly(0);
			Fragment rGroup =state.fragManager.buildSMILES("[Xe]");//TODO stop using actual atoms (confuses E/Z!)
			state.fragManager.createBond(inAtom, rGroup.getAtomByIDOrThrow(rGroup.getIdOfFirstAtom()), polymerBr.getOutID(0).valency);
			Atom outAtom =polymerBr.getOutAtomTakingIntoAccountWhetherSetExplicitly(1);
			rGroup =state.fragManager.buildSMILES("[Rn]");
			state.fragManager.createBond(outAtom, rGroup.getAtomByIDOrThrow(rGroup.getIdOfFirstAtom()), polymerBr.getOutID(1).valency);
			polymerBr.removeAllOutIDs();
		}
		else{
			throw new StructureBuildingException("Polymer building failed: Two termini were not found; Expected 2 outIDs, found: " +polymerBr.getOutIDCount() +" ,expected 0 inIDs, found: " +polymerBr.getInIDCount());
		}
	}

	private int resolvePreceedingFullWordsAndReturnNonFullIndice(BuildState state, Elements words) throws StructureBuildingException {
		for (int i = 0; i < words.size(); i++) {
			Element word =words.get(i);
			if (word.getAttributeValue("type").equals("full")){
				resolveWordOrBracket(state, word);
			}
			else{
				return i;
			}
		}
		throw new StructureBuildingException("No non full words were encountered!");
	}

	private void resolveTrailingFullWords(BuildState state, Elements words, int indice) throws StructureBuildingException {
		for (int i = indice; i < words.size(); i++) {
			Element word =words.get(i);
			if (word.getAttributeValue("type").equals("full")){
				resolveWordOrBracket(state, word);
			}
			else{
				throw new StructureBuildingException("Non full word found where only full words were expected");
			}
		}
	}

	/**
	 * Return the locant associated with the first child of a word if there is only child
	 * else returns null
	 * @param currentWord
	 * @return locant or null
	 */
	private String getLocantForSubstituent(Element currentWord) {
		Elements children = currentWord.getChildElements();
		if (children.size()==1){
			Element child =children.get(0);
			if (child.getAttribute("locant")!=null){
				return child.getAttributeValue("locant");
			}
			else{
				return null;
			}
		}
		else{
			return null;
		}
	}

	/**
	 * Finds a suitable functional atom corresponding to the given locant
	 * @param locant
	 * @param mainGroupBR
	 * @return functionalAtomToUse
	 * @throws StructureBuildingException
	 */
	private Atom determineFunctionalAtomToUse(String locant, BuildResults mainGroupBR) throws StructureBuildingException {
		for (int i = 0; i < mainGroupBR.getFunctionalIDCount(); i++) {
			Atom possibleAtom = mainGroupBR.getFunctionalAtom(i);
			if (possibleAtom.hasLocant(locant)){
				mainGroupBR.removeFunctionalID(i);
				return possibleAtom;
			}
		}
		if (matchDigits.matcher(locant).matches()){
			//None of the functional atoms had an appropriate locant. Look for the case whether the locant refers to the backbone. e.g. 5-methyl 2-aminopentanedioate
			for (int i = 0; i < mainGroupBR.getFunctionalIDCount(); i++) {
				Atom possibleAtom = mainGroupBR.getFunctionalAtom(i);
				if (OpsinTools.depthFirstSearchForNonSuffixAtomWithLocant(possibleAtom, locant)!=null){
					mainGroupBR.removeFunctionalID(i);
					return possibleAtom;
				}
			}
		}
		else{
			//None of the functional atoms had an appropriate locant. Look for the special case where the locant is used to decide on the ester configuration c.f. O-methyl ..thioate and S-methyl ..thioate
			for (int i = 0; i < mainGroupBR.getFunctionalIDCount(); i++) {
				Atom possibleAtom = mainGroupBR.getFunctionalAtom(i);
				if (possibleAtom.getNote("ambiguousElementAssignment")!=null){
					String[] atomIDs =possibleAtom.getNote("ambiguousElementAssignment").split(",");
                    for (String atomID : atomIDs) {
                        Atom a = mainGroupBR.getAtomByIdOrThrow(Integer.parseInt(atomID));
                        if (a.hasLocant(locant)) {
                            //swap locants and element type
                            List<String> tempLocants = new ArrayList<String>(a.getLocants());
                            List<String> tempLocants2 = new ArrayList<String>(possibleAtom.getLocants());
                            a.clearLocants();
                            possibleAtom.clearLocants();
                            for (String l : tempLocants) {
                                possibleAtom.addLocant(l);
                            }
                            for (String l : tempLocants2) {
                                a.addLocant(l);
                            }
                            String originalElement = possibleAtom.getElement();
                            possibleAtom.setElement(a.getElement());
                            a.setElement(originalElement);
                            mainGroupBR.removeFunctionalID(i);
                            return possibleAtom;
                        }
                    }
				}
			}
		}

		throw new StructureBuildingException("Cannot find functional atom with locant: " +locant + " to form an ester with");
	}

	/**
	 * Valency is used to determine the expected number of hydrogen
	 * Hydrogens are then added to bring the number of connections up to the minimum required to satisfy the atom's valency
	 * This allows the valency of the atom to be encoded e.g. phopshane-3 hydrogen, phosphorane-5 hydrogen.
	 * It is also neccesary when considering stereochemistry as a hydrogen beats nothing in the CIP rules
	 * @param state
	 * @throws StructureBuildingException
	 */
	private void makeHydrogensExplicit(BuildState state) throws StructureBuildingException {
		Set<Fragment> fragments = state.fragManager.getFragPile();
		for (Fragment fragment : fragments) {
			List<Atom> atomList =fragment.getAtomList();
			for (Atom parentAtom : atomList) {
				Integer valency =parentAtom.determineValency();
				int explicitHydrogensToAdd=0;
				if (valency !=null){
					explicitHydrogensToAdd=valency-parentAtom.getIncomingValency();
					parentAtom.setExplicitHydrogens(explicitHydrogensToAdd);
				}
				int currentId = 0;
				for (int i = 1; i <= explicitHydrogensToAdd; i++) {
					Atom a = state.fragManager.createAtom("H", fragment);
					state.fragManager.createBond(parentAtom, a, 1);
				}
				if (parentAtom.getAtomParityElement()!=null){
					if (explicitHydrogensToAdd >1){
						throw new StructureBuildingException("Cannot have tetrahedral chirality and more than 2 hydrogens");
					}
					if (explicitHydrogensToAdd ==1){
						Element atomParityEl = parentAtom.getAtomParityElement();
						Attribute atomRefs4Atr = atomParityEl.getAttribute("atomRefs4");
						String atomRefs4 = atomRefs4Atr.getValue();
						atomRefs4 = atomRefs4.replaceFirst("a" + parentAtom.getID() +"_H", "a" +currentId);//atom parity was set in SMILES but at this stage the id of the hydrogen was not known, now it is so replace the dummy ID
						atomRefs4Atr.setValue(atomRefs4);
					}
				}
			}
		}
	}
}
